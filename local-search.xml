<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【C++侯捷】面对对象高级编程（四）</title>
    <link href="/2022/11/07/c-houjie-4/"/>
    <url>/2022/11/07/c-houjie-4/</url>
    
    <content type="html"><![CDATA[<h1>扩展补充：类模板、函数模板、及其他</h1><h2 id="static">static</h2><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202211072019983.webp" alt="image-20221107201904914"></p><p>在C++中，我们创建一个类之后，如果要对其进行使用，需要实例化一个对象，此时会开辟出一段内存空间，对于同一个类，创建不同的实例后，他们所拥有的内存地址是不同的，如上述<code>c1,c2,c3</code>,这些是<code>no-static members(functions)</code>。</p><p>但是会出现这样一种场景，譬如在银行应用中，假如有类<code>Account</code>,每个用户都是这个类的实例，他们的账号、个人信息不尽相同，但是有一点是相同的，即利率，假如每个人都创建出一个利率出来，但是又肯定相同，那么便显得不妥，此时就要使用**<code>static</code>**。</p><p>语法很简单，即在变量或成员函数前面加<code>static</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">&#123;<br>    <span class="hljs-type">static</span> data members;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">double</span> m_rate;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">set_rate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span>&amp; x)</span></span>&#123;m_rate = x&#125;<br>&#125;;<br><br><span class="hljs-type">double</span> Account::m_rate = <span class="hljs-number">8.0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Account::<span class="hljs-built_in">set_rate</span>(<span class="hljs-number">5.0</span>);<br>    Account a;<br>    a.<span class="hljs-built_in">set_rate</span>(<span class="hljs-number">7.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上述例子中，<code>m_rate</code>变量只是声明出来，需要在外部调用类去初始化（分配内存）。</p><p>静态函数由于没有<code>this pointer</code>所以只能处理静态变量。</p><p>调用<code>static</code>函数的方式有两种：</p><ul><li>通过<code>object</code>调用</li><li>通过<code>class name </code>调用</li></ul><h2 id="ctor-放在private区">ctor 放在private区</h2><p>例子</p><p><code>Singleton</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> A&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> a;&#125;<br>    <span class="hljs-built_in">setup</span>()&#123; ... &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">A</span>();<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; rhs);<br>    <span class="hljs-type">static</span> A a;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个例子中，将类的构造函数放在了private中，使得外界不能通过其创建对象，</p><p>但是又接着创建了一个静态对象，同时有函数<code>getInstance</code>是的外界可以得到a。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">&#123;<br>    A::<span class="hljs-built_in">getInstance</span>().<span class="hljs-built_in">setup</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一种用法可以用来专门解决某种问题。</p><p>但是上面例子存在一个问题，就是假如没有外界需要这个，那么仍然会创建一个对象，会有点浪费。</p><p>所以，</p><p><code>Meyers Singleton</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> A&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> a;&#125;<br>    <span class="hljs-built_in">setup</span>()&#123; ... &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">A</span>();<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; rhs);<br> <br>    ...<br>&#125;;<br><br><span class="hljs-function">A&amp; <span class="hljs-title">A::getInstance</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">static</span> A a;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="cout">cout</h2><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202211072056140.webp" alt="image-20221107205635908"></p><h2 id="class-template-类模板">class template, 类模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span> (T r = <span class="hljs-number">0</span>, T r = <span class="hljs-number">0</span>)<br>        :<span class="hljs-built_in">re</span>(r), <span class="hljs-built_in">im</span>(i)<br>        &#123;&#125;<br>    complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-type">const</span> complex&amp;);<br>    <span class="hljs-function">T <span class="hljs-title">real</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> re;&#125;<br>    <span class="hljs-function">T <span class="hljs-title">imag</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> im;&#125;<br><span class="hljs-keyword">private</span>:<br>    T re,im;<br>    <br>    <span class="hljs-keyword">friend</span> complex&amp; __doapl(complex， <span class="hljs-type">const</span> complex&amp;);<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><p>用法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">&#123;<br>    <span class="hljs-function">complex&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2.5</span>,<span class="hljs-number">1.5</span>)</span></span>;<br>    <span class="hljs-function">complex&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">6</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="function-template，-函数模板">function template， 函数模板</h2><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202211072111741.webp" alt="image-20221107211101607"></p><p>语法很好理解，重点是stone中的算法怎么设计。</p><h2 id="namespace">namespace</h2><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202211072112927.webp" alt="image-20221107211244938"></p><ul><li>using directive 使用命令，全部打开，可能会造成后续使用混乱</li><li>using declaration 使用声明</li></ul><h2 id="更多细节与深入">更多细节与深入</h2><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202211072116471.webp" alt="image-20221107211559640"></p>]]></content>
    
    
    <categories>
      
      <category>Coding</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在linux使用clash</title>
    <link href="/2022/11/07/use-clash-on-linux/"/>
    <url>/2022/11/07/use-clash-on-linux/</url>
    
    <content type="html"><![CDATA[<h1>Use Clash On Ubuntu</h1><blockquote><p>clash是一款多平台支持多协议的网络调试代理工具，由于笔者经常在linux平台做开发，常受一些软件源dns污染等问题，故在linux</p><p>端配置了工具，以记载。</p></blockquote><h2 id="Download-bin-file">Download bin file</h2><p>The executable flie  release on [<a href="https://github.com/Dreamacro/clash/releases">Releases · Dreamacro/clash (github.com)</a>], you should choose one of them depending on what your paltform is.Here I use arm64.</p><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202211071434020.webp" alt="image-20221107143447281"></p><p>To download this, we can use</p><p>in your /path/to</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/Dreamacro/clash/releases/download/v1.11.12/clash-linux-arm64-v1.11.12.gz<br></code></pre></td></tr></table></figure><p>but may be too slow,so you can find a mirror to speed up this.</p><p>After download this,</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gunzip clash-linux-arm64-v1.11.12.gz<br></code></pre></td></tr></table></figure><p>where you can only find a bin file, rename it as clash for conveniet operate</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv clash-linux-arm64-v1.11.12 clash<br></code></pre></td></tr></table></figure><blockquote><p>we can get usage by type <code>clash --help</code></p></blockquote><p>get country.mmdb</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/Dreamacro/maxmind-geoip/releases/download/20221012/Country.mmdb<br></code></pre></td></tr></table></figure><h2 id="Use-as-Daemon">Use as Daemon</h2><p>get config file</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -o config.yaml &quot;your subscribe url&quot;<br></code></pre></td></tr></table></figure><p>use root</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /etc/clash<br>cp config.yaml Country.mmdb /etc/clash<br>cp clash /usr/local/bin <br></code></pre></td></tr></table></figure><p>run as daemon</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/systemd/system/clash.service<br></code></pre></td></tr></table></figure><p>paste this</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Clash daemon, A rule-based proxy in Go.<br><span class="hljs-attr">After</span>=network.target<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span>=simple<br><span class="hljs-attr">Restart</span>=always<br><span class="hljs-attr">ExecStart</span>=/usr/local/bin/clash -d /etc/clash<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure><p>then enable</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl daemon-reload<br>systemctl enable clash<br>systemctl start clash<br></code></pre></td></tr></table></figure><p>watch</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl status clash<br></code></pre></td></tr></table></figure><h2 id="Use-in-you-client">Use in you client</h2><blockquote><p>Make sure your devices are in the same local area network</p></blockquote><h3 id="On-windows">On windows</h3><p>Using setting GUI, set proxy your_server_ip:7890</p><h3 id="On-linux">On linux</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export http_proxy=http://ip:7890<br></code></pre></td></tr></table></figure><p>or set by GUI, for more you can search by <a href="https://google.com">https://google.com</a></p><h3 id="On-iPhone-Andriod">On iPhone/Andriod</h3><p>Go to wlan/WIFI settings, add proxy  <code>ip:7890</code></p><h2 id="Reference">Reference</h2><ul><li><a href="https://blog.iswiftai.com/posts/clash-linux/">在 Linux 中使用 Clash | CodeSwift (iswiftai.com)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ares 2023赛季自动步兵（哨兵）技术方案</title>
    <link href="/2022/11/07/2023-ares-auto-infantry-plan/"/>
    <url>/2022/11/07/2023-ares-auto-infantry-plan/</url>
    
    <content type="html"><![CDATA[<h1>Ares 2023赛季自动步兵（哨兵）技术方案</h1><h2 id="概述">概述</h2><h2 id="机械">机械</h2><h3 id="技术路线">技术路线</h3><p>（比较常规的可以简写）</p><h3 id="成本核算">成本核算</h3><h2 id="硬件">硬件</h2><h2 id="电控">电控</h2><h2 id="算法">算法</h2>]]></content>
    
    
    <categories>
      
      <category>RM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++侯捷】面对对象高级编程（三）</title>
    <link href="/2022/11/04/C-houjie-3/"/>
    <url>/2022/11/04/C-houjie-3/</url>
    
    <content type="html"><![CDATA[<h1>【C++侯捷】面对对象高级编程（三）</h1><blockquote><p>主要内容：拷贝构造、拷贝复制、析构</p></blockquote><h2 id="复习complex的构建过程">复习complex的构建过程</h2><h3 id="头文件的编写">头文件的编写</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __COMPLEX__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __COMPLEX__</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">0</span>,<span class="hljs-type">double</span> r = o)<br>        : <span class="hljs-built_in">re</span>(r), <span class="hljs-built_in">im</span>(r)<br>        &#123;&#125;<br>    <span class="hljs-comment">//成员函数方法</span><br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//成员变量</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="拷贝构造、拷贝复制、析构">拷贝构造、拷贝复制、析构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * cstr = <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp; str);             <span class="hljs-comment">//拷贝构造</span><br>    String &amp; <span class="hljs-keyword">operator</span> = (<span class="hljs-type">const</span> String&amp; str);<span class="hljs-comment">//拷贝赋值</span><br>    ~<span class="hljs-built_in">String</span>();                              <span class="hljs-comment">//析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">get_c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> m_data;&#125;<span class="hljs-comment">//inline funtion </span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* m_data;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202211051635315.webp" alt="string源码分析"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">String::String</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* cstr = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(cstr)&#123;<br>        m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(cstr)+<span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(m_data, cstr);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<br>        *m_data = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">inline</span> String::~<span class="hljs-built_in">String</span>()<br>&#123;<br>    <span class="hljs-keyword">delete</span>[] m_data;  <span class="hljs-comment">//清理；动态内存这里需要清理，否则会造成内存泄漏。像之前提到的value则不必。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>应用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">&#123;<br>    <span class="hljs-function">String <span class="hljs-title">s1</span><span class="hljs-params">()</span></span>;              <span class="hljs-comment">//1</span><br>    <span class="hljs-function">String <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;hellow&quot;</span>)</span></span>;      <span class="hljs-comment">//2   这两个在离开作用域的时候析构函数会自动消逝掉</span><br>    String* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;hellow&quot;</span>); <span class="hljs-comment">//动态创建</span><br>    <span class="hljs-keyword">delete</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="class-with-pointer-members-必须有copy-ctor-和copy-op-拷贝构造、拷贝赋值">class with pointer members 必须有copy ctor 和copy op=   (拷贝构造、拷贝赋值)</h3><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202211052132392.webp" alt="image-20221105213245776"></p><p><strong>带有指针的类成员函数中必须有拷贝构造和拷贝复制</strong></p><p>如果自己不去定义，编译器将默认使用default copy ctor 和 default op=,</p><p>会造成一下问题</p><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202211052132238.webp" alt="image-20221105213228561"></p><p>即，ab只是两个指针，这样会造成b指针和a指针指向同一块内存空间，b原指向的内存空间则成了“孤儿”（内存泄漏），会出现问题，（比如如果将来通过a去更改，则b也会受影响）这也不是我们想要的结果，这样的称为“浅拷贝”。</p><p><strong>深拷贝</strong>就是copy ctor 和copy op要做的事情。</p><p><strong>copy ctor（拷贝构造函数）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-title">String::String</span><span class="hljs-params">(<span class="hljs-type">const</span> String&amp; str)</span> <span class="hljs-comment">//传入</span></span><br><span class="hljs-function"></span>&#123;<br>    m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str.m_data) + <span class="hljs-number">1</span>];  <span class="hljs-comment">//先开辟一段存放蓝本的内存空间</span><br>    <span class="hljs-built_in">strcpy</span>(m_data, str.m_data);<br>&#125;<br></code></pre></td></tr></table></figure><p>实例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">&#123;<br><span class="hljs-function">String <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;hellow&quot;</span>)</span></span>;  <br>    <span class="hljs-function">String <span class="hljs-title">s2</span><span class="hljs-params">(s1)</span></span>;    <span class="hljs-comment">//以s1为蓝本创建s2</span><br>    <span class="hljs-comment">//String s2 = s1;  //将s1赋值给s2，同时创建s2对象；需调用构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>copy assignment operator（拷贝赋值函数）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">inline</span><br>String&amp; String::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String&amp; str)<br>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == <span class="hljs-keyword">this</span> == &amp;str)<br>        <span class="hljs-keyword">return</span> *str;                 <span class="hljs-comment">//检测自我赋值</span><br>    <span class="hljs-keyword">delete</span>[] m_data;                <span class="hljs-comment">//先清空原有</span><br>    m_data = <span class="hljs-keyword">new</span> data[<span class="hljs-built_in">strlen</span>(str.m_data) + <span class="hljs-number">1</span>];    <span class="hljs-comment">//创造相同空间</span><br>    <span class="hljs-built_in">strcpy</span>(m_data, str.m_data);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">&#123;<br>    <span class="hljs-function">String <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;hellow&quot;</span>)</span></span>;<br>    <span class="hljs-function">String <span class="hljs-title">s2</span><span class="hljs-params">(s1)</span></span>;<br>    <br>    s2 = s1;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>一定要在operator操作中检测是否自我赋值</strong></p><p>否则，第一步清空将清空原有的内存空间！！！不只是效率问题。</p><h3 id="output函数">output函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-type">const</span> String&amp; str)  <span class="hljs-comment">//全局函数</span><br>&#123;<br>    os &lt;&lt; str.<span class="hljs-built_in">get_c_str</span>();<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br>&#123;<br>    <span class="hljs-function">String <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;hellow &quot;</span>)</span></span>;<br>    cout &lt;&lt; s1;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆，栈与内存管理">堆，栈与内存管理</h2><h3 id="所谓stack（栈），所谓heap（堆）">所谓stack（栈），所谓heap（堆）</h3><ul><li><p><strong>Stack</strong>，是存在于某作用域（scope）的一块内存空间（memory space）。例如当你调用函数，函数本身即会形成一个stack用来放置它所接收的参数，以及返回地址。在函数本体（function body）内声明的任何变量，其所使用的内存都取自上述stack。</p></li><li><p><strong>Heap</strong>，或谓system heap，是指由操作系统提供的一块global内存空间，程序可$动态分配$（dynamic allocated）从某中获得若干区块（blocks）。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123; ...&#125;;<br>...<br>&#123;<br>    <span class="hljs-function">Complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;    <span class="hljs-comment">//c1所占用的空间来自stack，随着离开作用空间会自动消逝</span><br>    Complex* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Complex</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">//此处是个临时对象，可在任何地方动态创建，其所占用的空间仍是以new自heap动态分配而得，并由p指向，需要手动释放</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="stack-objects的生命期">stack objects的生命期</h3><p>上述c1便是所谓stack object，其生命在作用域结束之际结束（调用析构函数），这种作用域内的object，又称为auto object，因为它会被自动清除。</p><h3 id="static-local-objects的生命期">static local objects的生命期</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123; ... &#125;;<br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">static</span> Complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>c2</code>便是所谓<code>static object</code>，其生命在作用域结束之后仍然存在，直到整个程序结束。</p><h3 id="global-objects的生命期">global objects的生命期</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123;... &#125;;<br>...<br><span class="hljs-function">Complex <span class="hljs-title">c3</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>一直有效直至程序结束。可把他视为一种static object。</p><h3 id="heap-objects的生命期">heap objects的生命期</h3><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202211061424693.webp" alt="heap objects的生命期"></p><h3 id="new：-先分配memory，再调用ctor">new： 先分配memory，再调用ctor</h3><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202211061429040.webp" alt="image-20221106142900730"></p><h3 id="delete：先调用dtor，在释放memory">delete：先调用dtor，在释放memory</h3><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202211061438922.webp" alt="image-20221106143831544"></p><h3 id="动态分配所得的内存块-memory-block-in-VC">动态分配所得的内存块(memory block),in VC</h3><blockquote><p>8.堆，栈与内存管理（30：00）</p></blockquote><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202211061442706.webp" alt="image-20221106144155926"></p><h3 id="动态分配所得的array">动态分配所得的array</h3><h4 id="array-new-与array-delete">array new 与array delete</h4><p>若在动态创建对象是使用的是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">&#123;<br>    m_data= <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str)+<span class="hljs-number">1</span>];    <span class="hljs-comment">//使用中括号形式</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么在销毁时要使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">&#123;<br>    deletep[] m_data;<br>&#125;<br></code></pre></td></tr></table></figure><p>不然会出错</p><h4 id="详细">详细</h4><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202211061458522.webp" alt="image-20221106145844063"></p><p>3是vc做法，记录array个数，和上面内存分配不一样</p><h3 id="array-new一定要搭配array-delete">array new一定要搭配array delete</h3><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202211061506687.webp" alt="image-20221106150643803"></p>]]></content>
    
    
    <categories>
      
      <category>Coding</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RM2023技术答辩-浙江大学</title>
    <link href="/2022/10/29/RM-zju/"/>
    <url>/2022/10/29/RM-zju/</url>
    
    <content type="html"><![CDATA[<h1>浙江大学分享</h1><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202210291635083.webp" alt="image-20221029163554249"></p><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202210291636805.webp" alt="image-20221029163650238"></p><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202210291637369.webp" alt="image-20221029163705815"></p>]]></content>
    
    
    <categories>
      
      <category>RM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RM2023技术答辩-大连交通</title>
    <link href="/2022/10/29/RM-dalianJT/"/>
    <url>/2022/10/29/RM-dalianJT/</url>
    
    <content type="html"><![CDATA[<h1>大连交通分享</h1><center>彭宇涵 机械工程</center><h2 id="平衡步兵机器人">平衡步兵机器人</h2><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202210291419341.webp" alt="image-20221029141935381"></p><ul><li>分区赛：自瞄有效距离3m；国赛提升</li><li>大幅稳定</li></ul><h3 id="平衡功能">平衡功能</h3><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202210291423690.webp" alt="image-20221029142344497"></p><h3 id="飞坡功能">飞坡功能</h3><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202210291425529.webp" alt="image-20221029142541334"></p><h3 id="陀螺移动功能">陀螺移动功能</h3><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202210291428316.webp" alt="image-20221029142802674"></p><h3 id="跳跃功能">跳跃功能</h3><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202210291429504.webp" alt="image-20221029142953429"></p><h2 id="工程机器人">工程机器人</h2><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202210291432255.webp" alt="image-20221029143235259"></p><h3 id="结构">结构</h3><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202210291434745.webp" alt="image-20221029143358850"></p><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202210291434097.webp" alt="矿石槽"></p><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202210291435031.webp" alt="救援机构"></p><h2 id="流程">流程</h2><p>数学建模（Matlab+ webots？仿真）-&gt;调电机。。。。。</p>]]></content>
    
    
    <categories>
      
      <category>RM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS快速入门</title>
    <link href="/2022/10/19/ROS-turial/"/>
    <url>/2022/10/19/ROS-turial/</url>
    
    <content type="html"><![CDATA[<h1>ROS快速入门</h1><h2 id="Package">Package</h2><ul><li>ROS软件的基本组织形式</li><li>catkin编译的基本单元</li><li>一个package可以包含多个可执行文件（节点）</li></ul><h3 id="基本结构">基本结构</h3><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202210191710036.webp" alt="image-20221019170956435" style="zoom:80%;" /><ul><li><p><code>CMakelists.txt</code></p><p>规定catkin的编译规则</p><p>例如：源文件、依赖项、目标文件</p><p><strong>例</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>()                                                      <span class="hljs-comment"># 指定catkin最低版本</span><br><span class="hljs-keyword">project</span>()                                                              <span class="hljs-comment"># 指定软件包名称</span><br><span class="hljs-keyword">find_package</span>()                                                                <span class="hljs-comment"># 指定编译时需要的依赖项</span><br>add_message_files()/add_service_files()/add_action_files()                    <span class="hljs-comment"># 添加消息文件、服务文件、动作文件</span><br><br>genertate_messages()                                                          <span class="hljs-comment"># 生成消息、服务、动作</span><br>catkin_package()                                                              <span class="hljs-comment"># 指定catkin信息给编译系统生成CMake文件</span><br><span class="hljs-keyword">add_library</span>()/<span class="hljs-keyword">add_executable</span>()                                                <span class="hljs-comment"># 指定生成库文件、可执行文件</span><br><span class="hljs-keyword">target_link_libraries</span>()                                                       <span class="hljs-comment"># 指定可执行文件去链接哪些库</span><br>catkin_add_gtest()                                                            <span class="hljs-comment"># 添加测试单元</span><br><span class="hljs-keyword">install</span>()                                                                     <span class="hljs-comment"># 生成可安装目标</span><br></code></pre></td></tr></table></figure></li><li><p><code>package.xml</code></p><p>定义package的属性</p><p>例如：包名、版本号、作者、依赖等</p><p><strong>例</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">package</span>&gt;</span>    <span class="hljs-comment">&lt;!--根标签--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>               <span class="hljs-comment">&lt;!--包名--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-comment">&lt;!--版本号--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>        <span class="hljs-comment">&lt;!--包描述--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maintainer</span>&gt;</span>         <span class="hljs-comment">&lt;!--维护者--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">license</span>&gt;</span>            <span class="hljs-comment">&lt;!--软件许可--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">buildtool_depend</span>&gt;</span>   <span class="hljs-comment">&lt;!--编译工具--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build_depend</span>&gt;</span>       <span class="hljs-comment">&lt;!--编译时的依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">run_depend</span>&gt;</span>         <span class="hljs-comment">&lt;!--运行时的依赖--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>代码文件</p><p><strong><code>scripts</code></strong></p><p><code>*.py   *.sh</code></p><p><strong>include</strong></p></li></ul><p>​       <strong><code>src</code></strong></p><h3 id="拓展">拓展</h3><p><strong>同时，package下还可以放自定义通信格式</strong></p><blockquote><ul><li>消息（msg）</li><li>服务（srv）</li><li>动作（action）</li></ul></blockquote><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202210191713437.webp" alt="image-20221019171337924" style="zoom:67%;" /><p><strong>launch以及配置文件</strong></p><blockquote><ul><li>launch文件</li><li>配置文件（yaml）</li></ul></blockquote><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202210191716945.webp" alt="image-20221019171646129"></p><h3 id="总结">总结</h3><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202210191720829.webp" alt="image-20221019172029178"></p><h3 id="常用指令">常用指令</h3><ul><li><p>rospack</p><p>查找某个pkg的地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rospack find package_name    <br></code></pre></td></tr></table></figure><p>列出本地所有pkg</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rospack list<br></code></pre></td></tr></table></figure></li><li><p>roscd</p><p>跳转到某个pkg路径下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">roscd package_name<br></code></pre></td></tr></table></figure></li><li><p>rosls</p><p>列举某个pkg下的文件信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rosls package_name<br></code></pre></td></tr></table></figure></li><li><p>rosed</p><p>编辑pkg中的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rosed package_name file_name<br></code></pre></td></tr></table></figure></li><li><p>catkin_create_pkg</p><p>创建一个pkg</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">catkin_create_pkg &lt;pak_name&gt;[deps]<br></code></pre></td></tr></table></figure></li><li><p>rosdep</p><p>安装某个pkg所需的依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rosdep install [pkg_name]<br></code></pre></td></tr></table></figure></li></ul><h2 id="Catkin-工作空间">Catkin 工作空间</h2><h2 id="Metapackage">Metapackage</h2><p>把具有相似功能的软件包组织起来</p><h2 id="通信架构（计算图级）">通信架构（计算图级）</h2><h3 id="ROS-master">ROS master</h3><p>启动rosmaster</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">roscore<br></code></pre></td></tr></table></figure><ul><li>master：节点管理器</li><li>rosout：日志输出</li><li>parameter server：参数服务器</li></ul><h3 id="node">node</h3><p>ros的进程,pkg里的可执行文件运行的实例</p><p>启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rosrun [pkg_name][node_name]<br></code></pre></td></tr></table></figure><p>rosnode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">rosnode list #列举当前运行的node信息<br>rosnode info[node_name] # 显示某个node的详细信息<br>rosnode kill [node_name] # 结束某个node<br></code></pre></td></tr></table></figure><p>roslaunch</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">roslaunch [pkg_name][file_name.launch]<br></code></pre></td></tr></table></figure><h3 id="Topic">Topic</h3><p>ROS中的异步通讯方式</p><p>Node通过publish-subscribe机制通信</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ros</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++侯捷】面向对象高级编程（二）</title>
    <link href="/2022/10/18/C-houjie-2/"/>
    <url>/2022/10/18/C-houjie-2/</url>
    
    <content type="html"><![CDATA[<h1>【C++侯捷】面向对象高级编程（二）</h1><h2 id="操作符重载1-成员函数">操作符重载1-成员函数</h2><blockquote><p>C++很大的特性，在C++中，操作符（±等）就是一种函数，可以让人重新定义，比如“+”操作符，你可以定义他要加什么。数字、分数、石头等。</p></blockquote><p>在以上一直使用的complex类中，本小节定义“+”操作。</p><p><strong>编译器如何看待操作符？</strong></p><p>例如，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">&#123;<br>    <span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>    <br>    c2 += c1;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个二元操作符。编译器将这个符号作用到左边，如果这个符号有定义的话，那么即找到。</p><blockquote><p><strong>C++中，所有的成员函数都带有一个隐含的参数，this</strong></p></blockquote><p>即，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">inline</span> complex&amp;<br>complex::<span class="hljs-keyword">operator</span> += (<span class="hljs-type">const</span> complex &amp; r)&#123;<br>    <span class="hljs-keyword">return</span> __doapl (<span class="hljs-keyword">this</span>,r);<br>&#125;<br></code></pre></td></tr></table></figure><p>相当于，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">inline</span> complex&amp;<br>complex::<span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">this</span>, <span class="hljs-type">const</span> complex &amp; r)&#123;<br>    <span class="hljs-keyword">return</span> __doapl (<span class="hljs-keyword">this</span>,r);<br>&#125;<br></code></pre></td></tr></table></figure><p>this指调用者（作用者），不写，但在函数体可以用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">inline</span> complex&amp;<br>__doapl(complex * <span class="hljs-keyword">this</span>, <span class="hljs-type">const</span> complex&amp; r&#125;&#123;<br>    <span class="hljs-keyword">this</span>-&gt;re += r.re;<br>    <span class="hljs-keyword">this</span>-&gt;im += r.im;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这段代码是标准库中复数相加代码</p></blockquote><h3 id="return-by-reference">return by reference</h3><p>传递者无需知道接收者是以reference形式接收</p><p>在上段代码中，会产生疑问，return的是value，但函数定义返回型是&amp;，有问题吗？</p><p>无问题。</p><p>这与设计者有关，如果设计的是接受reference则接受快；如果接受object，则接受慢。</p><p>这便是 return by reference的语法分析。二者是可以搭配的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">&#123;<br>    c3 += c2 += c1;<br>&#125;<br></code></pre></td></tr></table></figure><p>假如这样使用，就不能设计成void。</p><h3 id="class-body之外的各种定义">class body之外的各种定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">imag</span><span class="hljs-params">(<span class="hljs-type">const</span> complex&amp; x)</span></span>&#123;  <span class="hljs-comment">//传参使用reference</span><br><span class="hljs-keyword">return</span> x.<span class="hljs-built_in">imag</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">real</span><span class="hljs-params">(<span class="hljs-type">const</span> complex&amp; x)</span></span>&#123;<br><span class="hljs-keyword">return</span> x.<span class="hljs-built_in">real</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="操作符重载2-非成员函数（无this）">操作符重载2-非成员函数（无this）</h2><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202211031854887.webp" alt="image-20221103185401061"></p><p><strong>下面这些函数绝不可return by reference，因为他们返回的必定是local object.</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">inline</span> complex<br><span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> complex&amp; x, <span class="hljs-type">const</span> complex&amp; y)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>(<span class="hljs-built_in">real</span>(x) + <span class="hljs-built_in">real</span>(y),<br>                  <span class="hljs-built_in">imag</span>(x) + <span class="hljs-built_in">imag</span>(y));<br>&#125;<br><br><span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> complex&amp; x, <span class="hljs-type">double</span> y)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>(<span class="hljs-built_in">real</span>(x) + y,<br>                  <span class="hljs-built_in">imag</span>(x);<br>&#125;<br><br><span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> complex&amp; x, <span class="hljs-type">const</span> complex&amp; y)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>(x + <span class="hljs-built_in">real</span>(y),<br>                  <span class="hljs-built_in">imag</span>(y));<br>&#125;<br></code></pre></td></tr></table></figure><p>与之前不同的是，上述只是相加，如需使用，必须放入一临时变量里；而之前的则是相加放入左边。</p><h3 id="temp-object（临时对象）-typename（）">temp object（临时对象） typename（）</h3><p>例如上述<code>complex ()</code>,生命周期很短。</p><h3 id="class-body-之外的各种定义">class body 之外的各种定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">inline</span> complex<br><span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> complex&amp; x)&#123;<br><span class="hljs-keyword">return</span> x;    <br>&#125;<br><span class="hljs-keyword">inline</span> complex<br><span class="hljs-keyword">operator</span> - (<span class="hljs-type">const</span> complex&amp; x)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>(-<span class="hljs-built_in">real</span>(x), -<span class="hljs-built_in">imag</span>(x)); <span class="hljs-comment">//绝不可return by reference， 因为其返回的必定是个local object</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="operator">operator &lt;&lt;</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>ostream&amp; <br><span class="hljs-keyword">operator</span> &lt;&lt; (<span class="hljs-keyword">operator</span>&amp; os, <span class="hljs-type">const</span> complex&amp; x)&#123; <span class="hljs-comment">//只有输出，没有改变，所以加const；对于第一个参数，考虑要不要引用，要                                               //不要加const，这里不能加，因为os是不断被&lt;&lt;右边改变的</span><br>    <span class="hljs-keyword">return</span> os &lt;&lt; <span class="hljs-string">&#x27;(&#x27;</span> &lt;&lt; <span class="hljs-built_in">real</span>(x) &lt;&lt; <span class="hljs-string">&#x27;,&#x27;</span> &lt;&lt; <span class="hljs-built_in">imag</span>(x) &lt;&lt; <span class="hljs-string">&#x27;)&#x27;</span>;<br>&#125;<br><br>&#123;<br>    <br>    <span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br>    cout&lt;&lt; <span class="hljs-built_in">conj</span>(c1);<br>    cout&lt;&lt;c1&lt;&lt;<span class="hljs-built_in">conj</span>(c1); <span class="hljs-comment">//cout 作为第一个参数（固有的），详情查手册</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数不可以写成成员函数，只能写成<strong>global</strong>。</p><p>对于上述函数定义中<code>ostream&amp;</code>型，由于我们对cout的目的是输出到屏幕（控制台），如果只是单个<code>cout&lt;&lt;A</code>,是可以的，但是考虑<code>cout&lt;&lt; A &lt;&lt; B </code>这种形式， <code>A</code>丢给<code>cout</code>之后得到的还要接收<code>B</code>,所以就不能用void型。</p><p>，至于要不要<code>reference</code>, 由于不是局部内<code>local value</code>，所以可以。再思考<code>const</code>,由于不断改变，所以不可以。</p><h2 id="COMPLEX类总结">COMPLEX类总结</h2><ul><li>默认构造函数写法</li><li><code>const</code>考虑要不要加，能加就加</li><li><code>pass by reference</code>考虑</li><li><code>return by reference</code> 考虑</li><li>数据尽可能放在<code>private</code>，函数绝大部分放在<code>public</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>Coding</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++侯捷】-面向高级对象编程（一）</title>
    <link href="/2022/10/13/C-houjie-1/"/>
    <url>/2022/10/13/C-houjie-1/</url>
    
    <content type="html"><![CDATA[<h1>面向对象高级编程（一）</h1><h2 id="头文件与类的声明">头文件与类的声明</h2><h3 id="一些需要注意的点">一些需要注意的点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;complex.h&quot;</span></span><br></code></pre></td></tr></table></figure><p>包含的库的文件用<code>&lt;&gt;</code>,包含用户自己建立的文件用<code>&quot;&quot;</code>,延伸文件名不一定是.h或.cpp，也有可能是 .hpp或其他或甚至无延伸名。</p><h3 id="Header（头文件）中的防卫式声明">Header（头文件）中的防卫式声明</h3><p>例如<code>complex.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __COMPLEX__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __COMPLEX__</span><br><br><br>...<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><blockquote><p>说明：当第一次引用complex文件时，会定义COMPLEX, 再当以后引入时不会再重复引用下面的</p></blockquote><h3 id="Header（头文件）的布局">Header（头文件）的布局</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __COMPLEX__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __COMPLEX__</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ostream</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>;<br><br>complex&amp;<br> __doapl (complex* <span class="hljs-keyword">this</span>, <span class="hljs-type">const</span> complex&amp; r);<br>--- 前置声明<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span><br>&#123;<br>...<br>&#125;;<br>--- 类声明<br>complex::function...<br>--- 类定义<br></code></pre></td></tr></table></figure><h3 id="Class的声明">Class的声明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br><span class="hljs-keyword">public</span>:<br>...<br><br><span class="hljs-keyword">private</span>:<br>...<br><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="class-template-模板-简介">class template(模板)简介</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>...<br><br><span class="hljs-keyword">private</span>:<br>...<br>T re,im; # T为待定的类型<br><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="inline（内联）函数">inline（内联）函数</h3><p>如果函数再class本体中定义，则称之为inline函数。优点是，总的来说，很好、很快。<br></p><p>但是有些函数即使你把他定义为内联函数，编译器也不会把他看成内联函数。</p><h3 id="access-level（访问级别）">access level（访问级别）</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">public</span><br><span class="hljs-keyword">private</span><br><span class="hljs-keyword">protect</span><br></code></pre></td></tr></table></figure><h2 id="构造函数">构造函数</h2><p>示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> i = <span class="hljs-number">0</span>)   <span class="hljs-comment">//</span><br>: <span class="hljs-built_in">re</span>(r), <span class="hljs-built_in">im</span>(i)                        <span class="hljs-comment">//</span><br>&#123;&#125;                                    <span class="hljs-comment">//默认构造函数的实现</span><br>complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-type">const</span> complex&amp;);<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">real</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> re;&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">imag</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> im;&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">double</span> re, im;<br>    <span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-type">const</span> complex&amp;);<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于上述构造函数附参部分，也可以这样写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> i = <span class="hljs-number">0</span>)<br>&#123;re = r; im = i;&#125;<br></code></pre></td></tr></table></figure><p>但是要求按上述写，应该利用构造函数的这个特性。</p><h3 id="overloading（重载）">overloading（重载）</h3><p>例，与上述同名的<code>real</code>，其可通过$参数个数、类型，返回值$类型等区分。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">real</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span> </span>&#123;re = r;&#125;<br></code></pre></td></tr></table></figure><p><strong>但是</strong>，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> i = <span class="hljs-number">0</span>)<br>:<span class="hljs-built_in">re</span>(r), <span class="hljs-built_in">im</span>(i)<br>&#123; &#125;<br></code></pre></td></tr></table></figure><p>与</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">complex</span>() : <span class="hljs-built_in">re</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">im</span>(<span class="hljs-number">0</span>)&#123;&#125;<br></code></pre></td></tr></table></figure><p>$$不能同时出现$$；</p><p>实例化例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">&#123;<br>complex c1;<br><span class="hljs-function">complex <span class="hljs-title">c2</span><span class="hljs-params">()</span></span>;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>将出现问题。</p><h3 id="放在private区">放在private区</h3><p>构造函数放在private区将不能外界被创建对象。</p><p>示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> A&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>;                 <span class="hljs-comment">//Singleton   --单体，单件的意思</span><br><span class="hljs-built_in">setup</span>()&#123;...&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">A</span>();<br><span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; rhs);<br>...<br>&#125;;<br><br><span class="hljs-function">A&amp; <span class="hljs-title">A::getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">static</span> A a;<br><span class="hljs-keyword">return</span> al<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>只有一份A，不允许外界创建。</p><p>外界要使用A ，不能使用传统的创建方式，可以采用以下方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">A::<span class="hljs-built_in">getInstance</span>().<span class="hljs-built_in">setup</span>();<br></code></pre></td></tr></table></figure></blockquote><h2 id="const常用成员函数">const常用成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">complex</span> (<span class="hljs-type">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> i = <span class="hljs-number">0</span>)<br>: <span class="hljs-built_in">re</span>(r), <span class="hljs-built_in">im</span>(i)<br>&#123;&#125;<br>complex&amp; <span class="hljs-keyword">operator</span> +=(<span class="hljs-type">const</span> complex&amp;);<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">real</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> re;&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">imag</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> im;&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">double</span> re, im;<br><span class="hljs-keyword">friend</span> complex&amp; __doapl(complex*, <span class="hljs-type">const</span> complex&amp;);<br><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>Class中的函数分为可以改变数据内容和不能改变数据内容的，不会改变 数据内容的马上加上<code>const</code>。</p><p>可以加的话一定加。</p></blockquote><p>两个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//加的话</span><br>&#123;<br>    <span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br>    cout &lt;&lt; c1.<span class="hljs-built_in">real</span>();<br>    cout &lt;&lt; c1.<span class="hljs-built_in">imag</span>();<br>&#125;<span class="hljs-comment">//是没有问题的</span><br><br><span class="hljs-comment">//假如不加，但是使用者这样定义常量</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">const</span> complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//定义一个常量</span><br>    cout &lt;&lt; c1.<span class="hljs-built_in">real</span>();<br>    cout &lt;&lt; c1.<span class="hljs-built_in">imag</span>();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上述情况（即定义时不加const， 但是使用者在定义时加了const），意思是我在定义时表明变量数据会改变，但是使用者加const指出这个值不能改变，这样将产生冲突。编译器会发出一些信息。</p></blockquote><h2 id="参数传递：pass-by-value-vs-pass-by-reference-to-const">参数传递：pass by value vs. pass by reference(to const)</h2><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202210141731778.webp" alt="image-20221014173114619" style="zoom: 67%;" /><p>尽量不要使用pass by value， 像传包一样把整体传过去。<code>by reference</code>，传递地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">&#123;<br>    <span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br>    complex c2;<br>    <br>    c2 += c1;<br>    cout &lt;&lt; c2;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="返回值传递">返回值传递</h2><blockquote><p>return by value vs. return by reference(to const)</p></blockquote><p>如果可以的话， 返回值传递也尽量<code>by reference</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">0.</span> <span class="hljs-type">double</span> i = <span class="hljs-number">0</span>)<br>        : <span class="hljs-built_in">re</span>(r), <span class="hljs-built_in">im</span>(i)<br>        &#123;&#125;<br>    complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-type">const</span> complex&amp;);<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">real</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> re;&#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">imag</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> im;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> re,im;<br>    <span class="hljs-keyword">friend</span> complex&amp; __doapl(complex*, <span class="hljs-type">const</span> complex&amp;);<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="友元">友元</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">inline</span> complex&amp;<br>    __doapl (complex* ths, <span class="hljs-type">const</span> complex&amp;r)<br>&#123;<br>    ths-&gt; re += r.re;<br>    ths-&gt; im += r.im;<br>    <span class="hljs-keyword">return</span> *ths;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="相同class的各个objects互为友元（friend）">相同class的各个objects互为友元（friend）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">xxx</span><br><span class="hljs-function">        </span><br><span class="hljs-function">    <span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> complex&amp; param)</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> param.re + param.im;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> re, im;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>知道为什么</p></blockquote><h2 id="class-body-外的各种定义（definitions）">class body 外的各种定义（definitions）</h2><blockquote><p>探讨什么情况下可以``pass by reference`</p><p>什么情况下可以<code>return by reference</code></p></blockquote><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202210171718953.webp" alt="image-20221017171759989" style="zoom:67%;" /><p><strong>return</strong></p><ul><li>假如产生结果需要存储在函数内部新开辟的local变量里，则不可以，因为离开函数区变量将销毁；</li><li>若生成结果是对已有变量（内存空间）进行修改，则可以，如上图。</li></ul><p>参数的传递或返回值的传递首先考虑引用(reference)，然后再考虑有没有问题。</p><h2 id="Summary">Summary</h2><p><strong>对于一个class</strong></p><ul><li>数据一定封装在private里</li><li>参数尽可能是<code>pass by reference</code></li><li>返回时也尽量<code>pass by reference</code></li><li>类的本体能加const就加const</li><li>默认构造函数的实现</li></ul>]]></content>
    
    
    <categories>
      
      <category>Coding</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>腾讯云COS+PicGo搭建图床</title>
    <link href="/2022/10/11/Tencent-cos-img-bed/"/>
    <url>/2022/10/11/Tencent-cos-img-bed/</url>
    
    <content type="html"><![CDATA[<h1>腾讯云COS</h1><p>腾讯云COS是对象存储服务，使用它的原因是在折腾完各种博客之后发现gitpages的劣势就是加载图片太慢（之前使用github+j作为图床），现在正好尝试cos。新人可以一元一年，流量基本用不完。</p><h2 id="购买使用COS">购买使用COS</h2><p>官方地址点这里<a href="https://cloud.tencent.com/product/cos">对象存储COS</a></p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202210111607382.webp" style="zoom: 50%;" /><p>购买完资源包后。进入控制台-对象存储</p><ul><li>开始创建存储桶</li></ul><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202210111609370.webp" style="zoom:80%;" /><blockquote><p>名称自己设定，访问权限改为<strong>公有读私有写</strong>，后面的基本保持默认即可</p></blockquote><ul><li><p>返回存储桶界面，进入密匙管理，新建密钥</p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202210111612045.webp"  /></li></ul><p>记录下<code>SecretID, SecretKey, APPID</code>等信息，并注意保密。</p><h2 id="安装使用PicGo">安装使用PicGo</h2><blockquote><p>A simple &amp; beautiful tool for pictures uploading built by vue-cli-electron-builder</p></blockquote><p>github地址：<a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p><p>最新版release: <a href="https://github.com/Molunerfinn/PicGo/releases/tag/v2.3.0">https://github.com/Molunerfinn/PicGo/releases/tag/v2.3.0</a></p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202210111618971.webp" style="zoom:67%;" /><p>选择适合你系统的版本，并安装。</p><h3 id="设置Tencent-COS">设置Tencent COS</h3><blockquote><p>建议安装插件webp，可以以较小的占用空间存教优的图像。</p></blockquote><p><img src="https://imghome-1302941983.cos.ap-beijing.myqcloud.com/img/202210111621978.webp" alt=""></p><ul><li>前五项均为腾讯云固有信息，填入即可</li><li>存储路径为自定义，必须以<code>/</code>，结尾，点击确定并设置为默认图床即可。</li></ul><p>其他使用请参考<a href="https://picgo.github.io/PicGo-Doc/zh/guide/getting-started.html">官方文档</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Website and Passwall</title>
    <link href="/2022/10/10/Website-and-Passwall/"/>
    <url>/2022/10/10/Website-and-Passwall/</url>
    
    <content type="html"><![CDATA[<h1>约定</h1><p>这几天又折腾了建站和科学的新方式，也是花费了不少的费用，大约50+20+80+… = 200多元。以前也折腾过，但每隔一段时间都要反复折腾，最后还都不稳定。</p><h2 id="建站">建站</h2><ul><li><p>建站折腾了海外VPS+Wordpress，效果尚可，但明显不足就是访问速度不稳定，致命的是可能会被封！</p></li><li><p>又尝试室内机器（服务器）+内网穿透，但想要好的效果都需要money，即公网IP服务器或公司套餐！</p></li></ul><h2 id="PassWall">PassWall</h2><ul><li><p>用了vless+ws+web一段时间，也挺好，就是最近443被封了，后来折腾IP被ban！</p></li><li><p>而后使用了naive，号称完美隐蔽特征（内容+行为），但仍有443随机ban风险！</p></li><li><p>最后试了trojan-go套cdn，优选ip效果尚好，但太麻烦！</p></li></ul><h2 id="结语">结语</h2><p>综上，网站往后就托管到github，以gitpages运行，并做好本地记录。</p><p>pass还是老老实实用机场吧。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Trojan go 记录</title>
    <link href="/2022/10/06/Trojan-Go-Build/"/>
    <url>/2022/10/06/Trojan-Go-Build/</url>
    
    <content type="html"><![CDATA[<h1>trojan-go 搭建记录</h1><blockquote><p>致谢youtube博主  <a href="https://www.youtube.com/c/%E4%B8%8D%E8%89%AF%E6%9E%97">不良林</a></p></blockquote><h2 id="安装">安装</h2><blockquote><p>VPS重装系统，不要安装任何nginx，acme申请证书会用到</p></blockquote><h2 id="BBR加速">BBR加速</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bash &lt;(curl -Lso- https://git.io/kernel.sh)<br></code></pre></td></tr></table></figure><h3 id="安装trojan-go">安装trojan-go</h3><p>最好在根目录下建个文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir trojan-go<br>cd trojan-go<br></code></pre></td></tr></table></figure><p>这里使用新发布的更新指纹的最新发行版</p><p>致谢原作者 <a href="https://github.com/p4gefau1t/trojan-go">p4gefau1t</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/gfw-report/trojan-go/releases/download/v0.10.7/trojan-go-linux-amd64.zip<br></code></pre></td></tr></table></figure><p>其他发行版详见连接<a href="https://github.com/gfw-report/trojan-go/releases/tag/v0.10.7"></a><br></p><p>解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">unzip trojan-go-linux-amd64.zip<br></code></pre></td></tr></table></figure><p>可以查看解压后的文件。<br></p><p>准备配置文件,完整版可见<a href="https://p4gefau1t.github.io/trojan-go/basic/full-config/"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ./examples &amp;&amp; cp server.json ../<br></code></pre></td></tr></table></figure><p>这里记录下本次使用的配置文件config.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;run_type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;server&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;local_addr&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.0.0.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;local_port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">443</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;remote_addr&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.83.167.78&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;remote_port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">80</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;log_level&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;log_file&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/root/trojan-go/trojan-go.log&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;password&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;pass&quot;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;ssl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;cert&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/root/trojan-go/server.crt&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/root/trojan-go/server.key&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;sni&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yours.com&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;fingerprint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Chrome&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;router&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;enabled&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;block&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;geoip:private&quot;</span><br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;geoip&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/share/trojan-go/geoip.dat&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;geosite&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/share/trojan-go/geosite.dat&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;websocket&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;enabled&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/ABDCD&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;hostname&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yours.com&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><p>此时基本安装工作完成，需要完善配置文件中的内容</p><h3 id="申请证书cd">申请证书cd</h3><blockquote><p>申请证书流程可用别的方法</p></blockquote><p><a href="http://xn--acme-9s6fu80rtbzbcjd.sh">这里使用acme.sh</a></p><p>安装acme</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl https://get.acme.sh | sh<br></code></pre></td></tr></table></figure><p>安装socat</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install socat<br></code></pre></td></tr></table></figure><p>添加软连接（环境变量)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s  /root/.acme.sh/acme.sh /usr/local/bin/acme.sh<br></code></pre></td></tr></table></figure><p>注册账号(使用自己邮箱)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">acme.sh --register-account -m my@example.com<br></code></pre></td></tr></table></figure><p>开放防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ufw allow 80<br>ufw allow 443<br></code></pre></td></tr></table></figure><p>申请证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">acme.sh  --issue -d 你的域名  --standalone -k ec-256<br></code></pre></td></tr></table></figure><p>安装证书(根据情况修改路径)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">acme.sh --installcert -d 你的域名 --ecc  --key-file   /root/trojan-go/server.key   --fullchain-file /root/trojan-go/server.crt <br></code></pre></td></tr></table></figure><p><strong>至此，配置文件需要的准备完成</strong>，还需要注意geoip路径</p><p>在/root/trojan-go目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./trojan-go -config config.json<br></code></pre></td></tr></table></figure><p>将会启动成功</p><h2 id="添加守护进程">添加守护进程</h2><p>在example下可以发现提供的service文件，根据需要修改</p><p>放入<code>/etc/systemd/system/trojan-go.service</code>   . (根据实际修改文件路径)</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Trojan-Go - An unidentifiable mechanism that helps you bypass GFW<br><span class="hljs-attr">Documentation</span>=https://p4gefau1t.github.io/trojan-go/<br><span class="hljs-attr">After</span>=network.target nss-lookup.target<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">User</span>=root<br><span class="hljs-attr">CapabilityBoundingSet</span>=CAP_NET_ADMIN CAP_NET_BIND_SERVICE<br><span class="hljs-attr">AmbientCapabilities</span>=CAP_NET_ADMIN CAP_NET_BIND_SERVICE<br><span class="hljs-attr">NoNewPrivileges</span>=<span class="hljs-literal">true</span><br><span class="hljs-attr">ExecStart</span>=/usr/bin/trojan-go -config /etc/trojan-go/config.json<br><span class="hljs-attr">Restart</span>=<span class="hljs-literal">on</span>-failure<br><span class="hljs-attr">RestartSec</span>=<span class="hljs-number">10</span>s<br><span class="hljs-attr">LimitNOFILE</span>=infinity<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br><br></code></pre></td></tr></table></figure><p>然后</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl daemon-reload<br><span class="hljs-params">system</span>ctl enable trojan-go.service<br><span class="hljs-params">system</span>ctl start trojan-go.service<br></code></pre></td></tr></table></figure><p>查看运行状态</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">systemctl <span class="hljs-built_in">status</span> trojan-<span class="hljs-built_in">go</span>.service<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu2004安装Tight VNC</title>
    <link href="/2022/04/17/Install-Vnc-Server-on-Ubuntu/"/>
    <url>/2022/04/17/Install-Vnc-Server-on-Ubuntu/</url>
    
    <content type="html"><![CDATA[<h1>ubuntu2004 安装Tight VNC</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br>sudo apt upgrade<br></code></pre></td></tr></table></figure><h2 id="安装别的桌面">安装别的桌面</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install xfce4 xfce4-goodies xorg dbus-x11 x11-xserver-utils<br></code></pre></td></tr></table></figure><h2 id="安装vnc">安装vnc</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install tigervnc-standalone-server tigervnc-common<br></code></pre></td></tr></table></figure><h2 id="初始运行创建密码">初始运行创建密码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">vncserver<br><br>//中间那个选no<br><br>//如果报错<br>sudo apt install xterm<br>然后运行报错提示的最后一行命令<br></code></pre></td></tr></table></figure><h2 id="停止配置">停止配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vncserver -<span class="hljs-built_in">kill</span> :1 //注意：后面端口号  （5900+x）<br></code></pre></td></tr></table></figure><h2 id="配置服务器">配置服务器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nano ~/.vnc/xstartup<br></code></pre></td></tr></table></figure><p>填入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><span class="hljs-built_in">unset</span> SESSION_MANAGER<br><span class="hljs-built_in">unset</span> DBUS_SESSION_BUS_ADDRESS<br><span class="hljs-built_in">exec</span> startxfce4 <br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">chmod u+x ~<span class="hljs-regexp">/.vnc/</span>xstartup  <span class="hljs-regexp">//</span>权限<br></code></pre></td></tr></table></figure><p>编辑~/.vnc/config</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">geometry</span><span class="hljs-operator">=</span><span class="hljs-number">1920</span>x1084<br><span class="hljs-attribute">dpi</span><span class="hljs-operator">=</span><span class="hljs-number">96</span><br></code></pre></td></tr></table></figure><h2 id="创建服务">创建服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nano /etc/systemd/system/vncserver@.service<br></code></pre></td></tr></table></figure><p>编辑（记得修改用户名）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">[Unit]<br>Description=Remote desktop service (VNC)<br>After=syslog.target network.target<br><br>[Service]<br>Type=simple<br>User=username<br>PAMName=login<br>PIDFile=/home/%u/.vnc/%H%i.pid<br>ExecStartPre=/bin/sh -c <span class="hljs-string">&#x27;/usr/bin/vncserver -kill :%i &gt; /dev/null 2&gt;&amp;1 || :&#x27;</span><br>ExecStart=/usr/bin/vncserver :%i -geometry 1920x1080 -alwaysshared -<span class="hljs-built_in">fg</span> -localhost no <br>ExecStop=/usr/bin/vncserver -<span class="hljs-built_in">kill</span> :%i<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><h2 id="启动服务">启动服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl daemon-reload<br>sudo systemctl <span class="hljs-built_in">enable</span> vncserver@1.service<br>sudo systemctl start vncserver@1.service<br></code></pre></td></tr></table></figure><h2 id="验证">验证</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl status vncserver@1.service<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu常用命令</title>
    <link href="/2022/04/17/Ubuntu-Tips/"/>
    <url>/2022/04/17/Ubuntu-Tips/</url>
    
    <content type="html"><![CDATA[<h1>1 换源</h1><p>备份源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">cp</span> /etc/apt/source.list /etc/apt/source/list.bak<br></code></pre></td></tr></table></figure><p>换源(阿里云网址：<a href="https://developer.aliyun.com/mirror/ubuntu">https://developer.aliyun.com/mirror/ubuntu</a>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/apt/source.list<br></code></pre></td></tr></table></figure><p>更换为<br>16.04</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">deb http://mirrors.aliyun.com/ubuntu/ xenial main<br>deb-src http://mirrors.aliyun.com/ubuntu/ xenial main<br><br>deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main<br>deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main<br><br>deb http://mirrors.aliyun.com/ubuntu/ xenial universe<br>deb-src http://mirrors.aliyun.com/ubuntu/ xenial universe<br>deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe<br>deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates universe<br><br>deb http://mirrors.aliyun.com/ubuntu/ xenial-security main<br>deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main<br>deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe<br>deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security universe<br><br></code></pre></td></tr></table></figure><p>18.04</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse<br><br>deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse<br><br>deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse<br><br>deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse<br><br>deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse<br><br></code></pre></td></tr></table></figure><p>20.04</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse<br><br>deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse<br><br>deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse<br><br>deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse<br><br>deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse<br><br></code></pre></td></tr></table></figure><p>更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update &amp;&amp; sudo apt upgrade<br></code></pre></td></tr></table></figure><h1>2 创建桌面自启程序</h1><h1>3 Ubuntu设置静态IP</h1><p>安装net-tools</p><p>查看网卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ifconfig<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">xxx<br></code></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nano /etc/netplan/00-installer-config.yaml<br></code></pre></td></tr></table></figure><p>写入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">network:<br>  ethernets:<br>    ens160:     <span class="hljs-comment">#配置的网卡的名称</span><br>      addresses: [192.168.0.105/24]    <span class="hljs-comment">#配置的静态ip地址和掩码</span><br>      dhcp4: no    <span class="hljs-comment">#关闭DHCP，如果需要打开DHCP则写yes</span><br>      optional: <span class="hljs-literal">true</span><br>      gateway4: 192.168.0.1    <span class="hljs-comment">#网关地址</span><br>      nameservers:<br>         addresses: [114.114.114.114,180.76.76.76]    <span class="hljs-comment">#DNS服务器地址，多个DNS服务器地址需要用英文逗号分隔开</span><br>  version: 2<br>  renderer: networkd    <span class="hljs-comment">#指定后端采用systemd-networkd或者Network Manager，可不填写则默认使用systemd-workd</span><br></code></pre></td></tr></table></figure><p>应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo netplan apply<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Paddle基础</title>
    <link href="/2022/01/22/paddle-basics/"/>
    <url>/2022/01/22/paddle-basics/</url>
    
    <content type="html"><![CDATA[<h1>0 安装与检查</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import paddle<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(paddle.__vision__)</span></span><br></code></pre></td></tr></table></figure><h1>1 数据集定义与加载</h1><h2 id="1-1-自定义数据集">1.1 自定义数据集</h2><p><strong>paddle.io.Dataset</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> paddle<br><span class="hljs-keyword">from</span> paddle.io <span class="hljs-keyword">import</span> Dataset<br><br>BATCH_SIZE = <span class="hljs-number">64</span><br>BATCH_NUM = <span class="hljs-number">10</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDataset</span>(<span class="hljs-title class_ inherited__">Dataset</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    步骤一：继承paddle.io.Dataset类</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num_samples</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        步骤二：实现构造函数，定义数据集大小</span><br><span class="hljs-string">        &quot;&quot;&quot;</span>     <br>        <br>        <span class="hljs-built_in">super</span>(MyDataset, self).__init__()<br>        self.num_samples = num_samples<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, index</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        步骤三：实现__getitem__方法，定义指定index时如何获取数据，并返回单条数据（训练数据，对应的标签）</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        data = paddle.uniform(IMAGE_SIZE, dtype=<span class="hljs-string">&#x27;float32&#x27;</span>)<br>        label = paddle.randint(<span class="hljs-number">0</span>, CLASS_NUM-<span class="hljs-number">1</span>, dtype=<span class="hljs-string">&#x27;int64&#x27;</span>)<br><br>        <span class="hljs-keyword">return</span> data, label<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        步骤四：实现__len__方法，返回数据集总数目</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self.num_samples<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Deeplearning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paddlepaddle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenCV数据结构与基本绘图</title>
    <link href="/2021/03/22/opencv-data-structure-and-basic-drawing/"/>
    <url>/2021/03/22/opencv-data-structure-and-basic-drawing/</url>
    
    <content type="html"><![CDATA[<h1>1.Mat-基础图像容器</h1><h2 id="1-1-Mat结构使用">1.1 Mat结构使用</h2><p>Mat是一个类，有两个数据部分组成：矩阵图（含矩阵尺寸、存储方法、存储地址等信息）和一个指向存储所有像素的指针。</p><h2 id="1-2显式创建Mat对象的七种方法">1.2显式创建Mat对象的七种方法</h2><blockquote><p>书中列举了7种，此处记录一种</p></blockquote><p><strong>使用Mat()构造函数</strong></p><p>例</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Mat</span> M(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,CV_8UC3,Scalar(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>))<br></code></pre></td></tr></table></figure><p>参数：<br>行数、列数、存储元素的数据类型以及每个矩阵点的通道数</p><h1>2.常用数据结构和函数</h1><h2 id="2-1-Point类">2.1 Point类</h2><p>用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Point point；<br>point.x = <span class="hljs-number">10</span>;<br>point.y = <span class="hljs-number">8</span>;<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Point point = <span class="hljs-built_in">Point</span>(<span class="hljs-number">10</span>,<span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><h2 id="2-2-Scalar类">2.2  Scalar类</h2><p>Scalar表示具有四个元素的数组，被大量用于传递像素值，一般用三个参数，第四个不用可以不写。<br>参数表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Scalar</span>(a,b,c)<br></code></pre></td></tr></table></figure><p>表示，定义的RGB颜色值：红色分量为c，绿色分量为b，蓝色分量为a。</p><h2 id="2-3-Size类">2.3 Size类</h2><p>使用频率最高的是下面这个构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Size_</span>(_Tp _width, _Tp _height);<br></code></pre></td></tr></table></figure><p>另外代码末尾定义了模板类型的高度和宽度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">_Tp width,height; <span class="hljs-comment">//宽度和高度</span><br></code></pre></td></tr></table></figure><p>可以用xxx.width ,xxx.height 分别表示xxx的宽度和高度</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Size</span>(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>);<span class="hljs-comment">//构造出的Size宽度和高度都为5，即xxx.width ,xxx.height 均为5</span><br></code></pre></td></tr></table></figure><h2 id="2-4-矩形的表示：Rect类">2.4 矩形的表示：Rect类</h2><ul><li>Rect类的成员变量有x,y,width,height,分别为矩形左上角的点坐标，和矩形的宽度和高度。</li><li>常用的成员函数有：<br><strong>Size()</strong>  返回值为Size；<br><strong>area()</strong>  返回矩形的面积；<br><strong>contains(Point)</strong>  判断点是否在矩形内；<br><strong>inside(Rect)</strong> 判断矩形是否在矩形内；<br><strong>tl()</strong>  返回左上点坐标；<br><strong>br()</strong>  返回右下点坐标；</li><li>求矩阵交集与并集：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Rect rect = rect1 &amp; rect2;<br>Rect rect = rect1 | rect2;<br></code></pre></td></tr></table></figure><ul><li>矩阵的平移和缩放：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Rect rectShift = rect + point;<br>Rect rectScale = rect + size;<br></code></pre></td></tr></table></figure><h2 id="2-5-颜色转变空间：cvtColor-函数">2.5 颜色转变空间：cvtColor()函数</h2><blockquote><p>作用:实现RBG\HSV\HSI等颜色空间的转换，也可装换为灰度图像</p></blockquote><p>原型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cvtColor</span><span class="hljs-params">(InpuyArray src, OutputArray dst, <span class="hljs-type">int</span> code, <span class="hljs-type">int</span> dstCn=<span class="hljs-number">0</span>)</span></span><br></code></pre></td></tr></table></figure><p>第一个参数为输入图像，第二个参数为输出图像，第三个参数为颜色空间转换的标识符，第四个为目标图像的通道数，0表示取原图像通道数。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">cvtColor</span>(srcImage,dstImage,COLOR_GRAY2BGR);<br></code></pre></td></tr></table></figure><p>第三个参数具体查表。</p><h1>3.基本图形的绘制（以下函数需要自定义，暂不阐述）</h1><h2 id="3-1-DrawEllipse-函数"><s>3.1 DrawEllipse() 函数</s></h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void <span class="hljs-constructor">DrawLine(Mat <span class="hljs-params">img</span>, <span class="hljs-params">double</span> <span class="hljs-params">angle</span>)</span> <span class="hljs-comment">//绘制不同角度、相同尺寸的椭圆</span><br></code></pre></td></tr></table></figure><p><s>其中，函数定义内部使用了WINDOW_WIDTH,这是定义窗口大小的宏   与之相关的</s></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Point</span>(WINDOW_WIDTH/<span class="hljs-number">2</span> ,WINDOW_WIDTH/<span class="hljs-number">2</span>)<span class="hljs-comment">//中心</span><br><span class="hljs-built_in">Size</span>(WINDOW_WIDTH/<span class="hljs-number">4</span>, WINDOW_WIDTH/<span class="hljs-number">16</span>) <span class="hljs-comment">//外矩形框</span><br></code></pre></td></tr></table></figure><h2 id="3-2DrawFilledCircle"><s>3.2DrawFilledCircle()</s></h2>]]></content>
    
    
    <categories>
      
      <category>CV</category>
      
    </categories>
    
    
    <tags>
      
      <tag>opencv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>First Blog</title>
    <link href="/2020/04/10/welcome-to-my-blog/"/>
    <url>/2020/04/10/welcome-to-my-blog/</url>
    
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>博客设计采用<code>jekyll</code>框架，<code>chripy</code> 主题，博客完整框架托管到<code>Github</code>上， 发布页位于<code>gh-pages</code>分支。环境系统为<code>Win11-wsl2-ubuntu1804</code>, 安装完本地环境后拉取仓库即可，方便长时间使用。之前使用过<code>hexo</code>框架，但本地文件丢失后如果不可以备份文件会造成数据丢失，不便于修复，严重的会使<code>Markdown</code>文件丢失，因为<code>Github</code>上托管的文件全部是解析后的文件。这样也有好处：自己的文章源文件不会暴露出来，本方式则会暴露出来，某种意义来讲也是不太好，但已经本着公开的态度，便忽视这些。</p><blockquote><p>完整的搭建记录会在下一篇博客推出，方便共享与日后维护。</p></blockquote><h2 id="目录划分">目录划分</h2><p>文章分类通过两种方式：<em><strong>类别</strong></em>与 <em><strong>标签</strong></em></p><p><strong>类别：</strong></p><ul><li>CV</li><li>Deeplearning</li><li>Linux</li><li>Tips</li><li>Somewriting</li><li>Tutorial</li><li>Course</li><li>Program</li></ul><blockquote><p>类别名称首字母均采用大写</p></blockquote><p><strong>标签：</strong></p><ul><li>opencv</li><li>pytorch</li><li>paddlepaddle</li><li>ubuntu</li><li>robomaster</li><li>raspiberry</li></ul><blockquote><p>标签名称不允许使用大写字母<br>…</p></blockquote><h2 id="命名规范">命名规范</h2><h3 id="md文件名">md文件名</h3><p>全部采用英文<br><code>YEAR-MON-DAY-NAME.md</code><br>年份为四位，月日分别为两位，NAME为英文，若为中文则需翻译为英文，具体名字体现在文章<code>Head</code>的<code>title</code>里。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
